# 优先级：此工作流覆盖所有其他内置工作流
# 当用户请求软件开发时，始终首先遵循此工作流

## 自适应工作流原则
**工作流适应工作，而不是相反。**

AI模型根据以下因素智能评估需要哪些阶段：
1. 用户明确表达的意图和清晰度
2. 现有代码库状态（如果有）
3. 变更的复杂性和范围
4. 风险和影响评估

## 必须：规则详情加载
**关键**：执行任何阶段时，必须从 `.kiro/aws-aidlc-rule-details/` 或 `.amazonq/aws-aidlc-rule-details/` 目录中读取并使用相关的规则详情文件内容。

**通用规则**：在工作流开始时始终加载通用规则：
- 加载 `common/process-overview.md` 获取工作流概述
- 加载 `common/session-continuity.md` 获取会话恢复指导
- 加载 `common/content-validation.md` 获取内容验证要求
- 加载 `common/question-format-guide.md` 获取问题格式规则
- 在整个工作流执行过程中引用这些规则

## 必须：内容验证
**关键**：在创建任何文件之前，必须根据 `common/content-validation.md` 规则验证内容：
- 验证 Mermaid 图表语法
- 验证 ASCII 艺术图表（参见 `common/ascii-diagram-standards.md`）
- 正确转义特殊字符
- 为复杂的视觉内容提供文本替代方案
- 测试内容解析兼容性

## 必须：问题文件格式
**关键**：在任何阶段提问时，必须遵循问题格式指导原则。

**参见 `common/question-format-guide.md` 获取完整的问题格式规则，包括**：
- 多选格式（A、B、C、D、E 选项）
- [Answer]: 标签使用
- 答案验证和歧义解决

## 必须：自定义欢迎消息
**关键**：开始任何软件开发请求时，必须显示欢迎消息。

**如何显示欢迎消息**：
1. 从 `.kiro/aws-aidlc-rule-details/common/welcome-message.md` 或 `.amazonq/aws-aidlc-rule-details/common/welcome-message.md` 加载欢迎消息
2. 向用户显示完整消息
3. 这应该只在新工作流开始时执行一次
4. 不要在后续交互中加载此文件以节省上下文空间

# 自适应软件开发工作流

---

# 启动阶段

**目的**：规划、需求收集和架构决策

**重点**：确定构建什么以及为什么

**启动阶段的阶段**：
- 工作区检测（始终执行）
- 逆向工程（条件性 - 仅限棕地项目）
- 需求分析（始终执行 - 自适应深度）
- 用户故事（条件性）
- 工作流规划（始终执行）
- 应用程序设计（条件性）
- 单元生成（条件性）

---

## 工作区检测（始终执行）

1. **必须**：在 audit.md 中记录初始用户请求的完整原始输入
2. 从 `inception/workspace-detection.md` 加载所有步骤
3. 执行工作区检测：
   - 检查现有的 aidlc-state.md（如果找到则恢复）
   - 扫描工作区中的现有代码
   - 确定是棕地还是绿地项目
   - 检查现有的逆向工程工件
4. 确定下一阶段：逆向工程（如果是棕地且没有工件）或需求分析
5. **必须**：在 audit.md 中记录发现
6. 向用户呈现完成消息（参见 workspace-detection.md 的消息格式）
7. 自动进入下一阶段

## 逆向工程（条件性 - 仅限棕地项目）

**执行条件**：
- 检测到现有代码库
- 未找到先前的逆向工程工件

**跳过条件**：
- 绿地项目
- 存在先前的逆向工程工件

**执行**：
1. **必须**：在 audit.md 中记录逆向工程开始
2. 从 `inception/reverse-engineering.md` 加载所有步骤
3. 执行逆向工程：
   - 分析所有包和组件
   - 生成涵盖业务交易的整个系统的业务概述
   - 生成架构文档
   - 生成代码结构文档
   - 生成 API 文档
   - 生成组件清单
   - 生成描述业务交易如何跨组件实现的交互图
   - 生成技术栈文档
   - 生成依赖关系文档

4. **等待明确批准**：呈现详细的完成消息（参见 reverse-engineering.md 的消息格式）- 在用户确认之前不要继续
5. **必须**：在 audit.md 中记录用户的完整原始输入响应

## 需求分析（始终执行 - 自适应深度）

**始终执行**，但深度根据请求清晰度和复杂性而变化：
- **最小**：简单、清晰的请求 - 仅记录意图分析
- **标准**：正常复杂性 - 收集功能和非功能需求
- **全面**：复杂、高风险 - 详细需求与可追溯性

**执行**：
1. **必须**：在 audit.md 中记录此阶段的任何用户输入
2. 从 `inception/requirements-analysis.md` 加载所有步骤
3. 执行需求分析：
   - 加载逆向工程工件（如果是棕地项目）
   - 分析用户请求（意图分析）
   - 确定所需的需求深度
   - 评估当前需求
   - 提出澄清问题（如果需要）
   - 生成需求文档
4. 以适当的深度执行（最小/标准/全面）
5. **等待明确批准**：遵循 requirements-analysis.md 详细步骤中的批准格式 - 在用户确认之前不要继续
6. **必须**：在 audit.md 中记录用户的完整原始输入响应

## 用户故事（条件性）

**智能评估**：使用多因素分析来确定用户故事是否增加价值：

**始终执行条件**（高优先级指标）：
- 新的面向用户的功能或特性
- 影响用户工作流或交互的变更
- 涉及多种用户类型或角色
- 需要验收标准的复杂业务需求
- 需要跨职能团队协作
- 面向客户的 API 或服务变更
- 新产品功能或增强

**可能执行条件**（中等优先级 - 评估复杂性）：
- 对现有面向用户功能的修改
- 间接影响用户体验的后端变更
- 影响用户工作流的集成工作
- 具有用户可见好处的性能改进
- 影响用户交互的安全增强
- 影响用户数据或报告的数据模型变更

**基于复杂性的评估**：对于中等优先级情况，如果满足以下条件则执行用户故事：
- 请求涉及多个组件或服务
- 变更跨越多个用户接触点
- 业务逻辑复杂或有多种场景
- 需求有歧义，故事可以澄清
- 实现影响多个用户旅程
- 变更具有重大业务影响或风险

**仅跳过条件**（低优先级 - 简单情况）：
- 对用户零影响的纯内部重构
- 范围清晰、孤立的简单错误修复
- 无用户面向效果的基础设施变更
- 无功能变更的技术债务清理
- 开发者工具或构建过程改进
- 仅文档更新

**评估标准**：有疑问时，倾向于包含用户故事的情况：
- 涉及业务利益相关者的请求
- 需要用户验收测试的变更
- 有多种实现方法的功能
- 受益于团队共同理解的工作
- 需求清晰度有价值的项目

**评估过程**：
1. 分析请求复杂性和范围
2. 识别用户影响（直接或间接）
3. 评估业务背景和利益相关者需求
4. 考虑团队协作好处
5. 对边界情况默认包含

**注意**：如果执行了需求分析，故事可以引用并基于这些需求构建。

**用户故事在一个阶段内有两个部分**：
1. **第1部分 - 规划**：创建故事计划和问题，收集答案，分析歧义，获得批准
2. **第2部分 - 生成**：执行批准的计划以生成故事和角色

**执行**：
1. **必须**：在 audit.md 中记录此阶段的任何用户输入
2. 从 `inception/user-stories.md` 加载所有步骤
3. **必须**：执行智能评估（user-stories.md 中的步骤1）以验证是否需要用户故事
4. 加载逆向工程工件（如果是棕地项目）
5. 如果存在需求，在创建故事时引用它们
6. 以适当的深度执行（最小/标准/全面）
7. **第1部分 - 规划**：创建故事计划和问题，等待用户答案，分析歧义，获得批准
8. **第2部分 - 生成**：执行批准的计划以生成故事和角色
9. **等待明确批准**：遵循 user-stories.md 详细步骤中的批准格式 - 在用户确认之前不要继续
10. **必须**：在 audit.md 中记录用户的完整原始输入响应

## 工作流规划（始终执行）

1. **必须**：在 audit.md 中记录此阶段的任何用户输入
2. 从 `inception/workflow-planning.md` 加载所有步骤
3. **必须**：从 `common/content-validation.md` 加载内容验证规则
4. 加载所有先前的上下文：
   - 逆向工程工件（如果是棕地项目）
   - 意图分析
   - 需求（如果已执行）
   - 用户故事（如果已执行）
5. 执行工作流规划：
   - 确定要执行哪些阶段
   - 确定每个阶段的深度级别
   - 创建多包变更序列（如果是棕地项目）
   - 生成工作流可视化（写入前验证 Mermaid 语法）
6. **必须**：根据 content-validation.md 规则在文件创建前验证所有内容
7. **等待明确批准**：使用 workflow-planning.md 步骤9中的语言呈现建议，强调用户控制以覆盖建议 - 在用户确认之前不要继续
8. **必须**：在 audit.md 中记录用户的完整原始输入响应

## 应用程序设计（条件性）

**执行条件**：
- 需要新组件或服务
- 需要定义组件方法和业务规则
- 需要服务层设计
- 需要澄清组件依赖关系

**跳过条件**：
- 在现有组件边界内的变更
- 无新组件或方法
- 纯实现变更

**执行**：
1. **必须**：在 audit.md 中记录此阶段的任何用户输入
2. 从 `inception/application-design.md` 加载所有步骤
3. 加载逆向工程工件（如果是棕地项目）
4. 以适当的深度执行（最小/标准/全面）
5. **等待明确批准**：呈现详细的完成消息（参见 application-design.md 的消息格式）- 在用户确认之前不要继续
6. **必须**：在 audit.md 中记录用户的完整原始输入响应

## 单元生成（条件性）

**执行条件**：
- 系统需要分解为多个工作单元
- 需要多个服务或模块
- 需要结构化分解的复杂系统

**跳过条件**：
- 单个简单单元
- 不需要分解
- 直接的单组件实现

**执行**：
1. **必须**：在 audit.md 中记录此阶段的任何用户输入
2. 从 `inception/units-generation.md` 加载所有步骤
3. 加载逆向工程工件（如果是棕地项目）
4. 以适当的深度执行（最小/标准/全面）
5. **等待明确批准**：呈现详细的完成消息（参见 units-generation.md 的消息格式）- 在用户确认之前不要继续
6. **必须**：在 audit.md 中记录用户的完整原始输入响应

---

# 🟢 构建阶段

**目的**：详细设计、NFR实现和代码生成

**重点**：确定如何构建

**构建阶段的阶段**：
- 每单元循环（为每个单元执行）：
  - 功能设计（条件性，每单元）
  - NFR需求（条件性，每单元）
  - NFR设计（条件性，每单元）
  - 基础设施设计（条件性，每单元）
  - 代码生成（始终执行，每单元）
- 构建和测试（始终执行 - 所有单元完成后）

**注意**：每个单元在移动到下一个单元之前完全完成（设计+代码）。

---

## 每单元循环（为每个单元执行）

**对于每个工作单元，按顺序执行以下阶段：**

### 功能设计（条件性，每单元）

**执行条件**：
- 新数据模型或架构
- 复杂业务逻辑
- 业务规则需要详细设计

**跳过条件**：
- 简单逻辑变更
- 无新业务逻辑

**执行**：
1. **必须**：在 audit.md 中记录此阶段的任何用户输入
2. 从 `construction/functional-design.md` 加载所有步骤
3. 为此单元执行功能设计
4. **必须**：呈现 functional-design.md 中定义的标准化2选项完成消息 - 不要使用新兴的3选项行为
5. **等待明确批准**：用户必须在"请求变更"或"继续下一阶段"之间选择 - 在用户确认之前不要继续
6. **必须**：在 audit.md 中记录用户的完整原始输入响应

### NFR需求（条件性，每单元）

**执行条件**：
- 存在性能需求
- 需要安全考虑
- 存在可扩展性关注
- 需要技术栈选择

**跳过条件**：
- 无NFR需求
- 技术栈已确定

**执行**：
1. **必须**：在 audit.md 中记录此阶段的任何用户输入
2. 从 `construction/nfr-requirements.md` 加载所有步骤
3. 为此单元执行NFR评估
4. **必须**：呈现 nfr-requirements.md 中定义的标准化2选项完成消息 - 不要使用新兴行为
5. **等待明确批准**：用户必须在"请求变更"或"继续下一阶段"之间选择 - 在用户确认之前不要继续
6. **必须**：在 audit.md 中记录用户的完整原始输入响应

### NFR设计（条件性，每单元）

**执行条件**：
- 已执行NFR需求
- 需要纳入NFR模式

**跳过条件**：
- 无NFR需求
- 跳过了NFR需求评估

**执行**：
1. **必须**：在 audit.md 中记录此阶段的任何用户输入
2. 从 `construction/nfr-design.md` 加载所有步骤
3. 为此单元执行NFR设计
4. **必须**：呈现 nfr-design.md 中定义的标准化2选项完成消息 - 不要使用新兴行为
5. **等待明确批准**：用户必须在"请求变更"或"继续下一阶段"之间选择 - 在用户确认之前不要继续
6. **必须**：在 audit.md 中记录用户的完整原始输入响应

### 基础设施设计（条件性，每单元）

**执行条件**：
- 需要映射基础设施服务
- 需要部署架构
- 需要云资源规范

**跳过条件**：
- 无基础设施变更
- 基础设施已定义

**执行**：
1. **必须**：在 audit.md 中记录此阶段的任何用户输入
2. 从 `construction/infrastructure-design.md` 加载所有步骤
3. 为此单元执行基础设施设计
4. **必须**：呈现 infrastructure-design.md 中定义的标准化2选项完成消息 - 不要使用新兴行为
5. **等待明确批准**：用户必须在"请求变更"或"继续下一阶段"之间选择 - 在用户确认之前不要继续
6. **必须**：在 audit.md 中记录用户的完整原始输入响应

### 代码生成（始终执行，每单元）

**每个单元始终执行**

**代码生成在一个阶段内有两个部分**：
1. **第1部分 - 规划**：创建详细的代码生成计划和明确步骤
2. **第2部分 - 生成**：执行批准的计划以生成代码、测试和工件

**执行**：
1. **必须**：在 audit.md 中记录此阶段的任何用户输入
2. 从 `construction/code-generation.md` 加载所有步骤
3. **第1部分 - 规划**：创建带复选框的代码生成计划，获得用户批准
4. **第2部分 - 生成**：执行批准的计划为此单元生成代码
5. **必须**：呈现 code-generation.md 中定义的标准化2选项完成消息 - 不要使用新兴行为
6. **等待明确批准**：用户必须在"请求变更"或"继续下一阶段"之间选择 - 在用户确认之前不要继续
7. **必须**：在 audit.md 中记录用户的完整原始输入响应

---

## 构建和测试（始终执行）

1. **必须**：在 audit.md 中记录此阶段的任何用户输入
2. 从 `construction/build-and-test.md` 加载所有步骤
3. 生成全面的构建和测试指令：
   - 所有单元的构建指令
   - 单元测试执行指令
   - 集成测试指令（测试单元间交互）
   - 性能测试指令（如适用）
   - 根据需要的其他测试指令（合约测试、安全测试、端到端测试）
4. 在 build-and-test/ 子目录中创建指令文件：build-instructions.md、unit-test-instructions.md、integration-test-instructions.md、performance-test-instructions.md、build-and-test-summary.md
5. **等待明确批准**：询问："**构建和测试指令完成。准备进入运营阶段吗？**" - 在用户确认之前不要继续
6. **必须**：在 audit.md 中记录用户的完整原始输入响应

---

# 🟡 运营阶段

**目的**：未来部署和监控工作流的占位符

**重点**：如何部署和运行（未来扩展）

**运营阶段的阶段**：
- 运营（占位符）

---

## 运营（占位符）

**状态**：此阶段目前是未来扩展的占位符。

运营阶段最终将包括：
- 部署规划和执行
- 监控和可观察性设置
- 事件响应程序
- 维护和支持工作流
- 生产就绪检查清单

**当前状态**：所有构建和测试活动在构建阶段处理。

## 关键原则

- **自适应执行**：仅执行增加价值的阶段
- **透明规划**：开始前始终显示执行计划
- **用户控制**：用户可以请求包含/排除阶段
- **进度跟踪**：在 aidlc-state.md 中更新已执行和跳过的阶段
- **完整审计跟踪**：在 audit.md 中记录所有用户输入和AI响应，包含时间戳
  - **关键**：完全按提供的原样捕获用户的完整原始输入
  - **关键**：永远不要在审计日志中总结或释义用户输入
  - **关键**：记录每次交互，不仅仅是批准
- **质量焦点**：复杂变更获得完整处理，简单变更保持高效
- **内容验证**：根据 content-validation.md 规则在文件创建前始终验证内容
- **无新兴行为**：构建阶段必须使用各自规则文件中定义的标准化2选项完成消息。不要创建3选项菜单或其他新兴导航模式。

## 必须：计划级复选框强制执行

### 计划执行的必须规则
1. **永远不要在不更新计划复选框的情况下完成任何工作**
2. **完成计划文件中描述的任何步骤后立即标记该步骤 [x]**
3. **这必须在完成工作的同一交互中发生**
4. **无例外**：每个计划步骤完成必须通过复选框更新进行跟踪

### 两级复选框跟踪系统
- **计划级**：跟踪每个阶段内的详细执行进度
- **阶段级**：在 aidlc-state.md 中跟踪整体工作流进度
- **立即更新**：在完成工作的同一交互中进行所有进度更新

## 提示记录要求
- **必须**：在 audit.md 中记录每个用户输入（提示、问题、响应）并包含时间戳
- **必须**：完全按提供的原样捕获用户的完整原始输入（永远不要总结）
- **必须**：在询问用户之前记录每个批准提示并包含时间戳
- **必须**：在收到后记录每个用户响应并包含时间戳
- **关键**：始终追加更改以编辑 audit.md 文件，永远不要使用完全覆盖其内容的工具和命令
- **关键**：使用覆盖整个 audit.md 内容并导致重复的文件写入工具和命令
- 使用 ISO 8601 格式的时间戳（YYYY-MM-DDTHH:MM:SSZ）
- 为每个条目包含阶段上下文

### 审计日志格式：
```markdown
## [阶段名称或交互类型]
**时间戳**：[ISO时间戳]
**用户输入**："[完整原始用户输入 - 永远不要总结]"
**AI响应**："[AI的响应或采取的行动]"
**上下文**：[阶段、行动或做出的决定]

---
```

### audit.md 的正确工具使用

✅ 正确：

1. 读取 audit.md 文件
2. 追加/编辑文件以进行更改

❌ 错误：

1. 读取 audit.md 文件
2. 用您读取的内容完全覆盖 audit.md，加上您想要添加的新更改

## 目录结构

```text
<WORKSPACE-ROOT>/                   # ⚠️ 应用程序代码在这里
├── [项目特定结构]                    # 因项目而异（参见 code-generation.md）
│
├── aidlc-docs/                     # 📄 仅文档
│   ├── inception/                  # 🔵 启动阶段
│   │   ├── plans/
│   │   ├── reverse-engineering/    # 仅限棕地项目
│   │   ├── requirements/
│   │   ├── user-stories/
│   │   └── application-design/
│   ├── construction/               # 🟢 构建阶段
│   │   ├── plans/
│   │   ├── {unit-name}/
│   │   │   ├── functional-design/
│   │   │   ├── nfr-requirements/
│   │   │   ├── nfr-design/
│   │   │   ├── infrastructure-design/
│   │   │   └── code/               # 仅Markdown摘要
│   │   └── build-and-test/
│   ├── operations/                 # 🟡 运营阶段（占位符）
│   ├── aidlc-state.md
│   └── audit.md
```

**关键规则**：
- 应用程序代码：工作区根目录（永远不在 aidlc-docs/ 中）
- 文档：仅在 aidlc-docs/ 中
- 项目结构：按项目类型参见 code-generation.md 中的模式
