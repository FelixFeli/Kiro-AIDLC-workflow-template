# 代码生成 - 详细步骤

## 概述
此阶段通过两个集成部分为每个工作单元生成代码：
- **第 1 部分 - 规划**：创建详细的代码生成计划和明确步骤
- **第 2 部分 - 生成**：执行批准的计划以生成代码、测试和工件

**注意**：对于棕地项目，"生成"意味着在适当时修改现有文件，而不是创建重复文件。

## 先决条件
- 单元的单元设计生成必须完成
- NFR 实现（如果已执行）必须为单元完成
- 所有单元设计工件必须可用
- 单元已准备好进行代码生成

---

# 第 1 部分：规划

## 步骤 1：分析单元上下文
- [ ] 从单元设计生成中读取单元设计工件
- [ ] 读取单元故事映射以了解分配的故事
- [ ] 识别单元依赖关系和接口
- [ ] 验证单元已准备好进行代码生成

## 步骤 2：创建详细的单元代码生成计划
- [ ] 从 `aidlc-docs/aidlc-state.md` 读取工作区根目录和项目类型
- [ ] 确定代码位置（参见关键规则中的结构模式）
- [ ] **仅棕地项目**：审查逆向工程 code-structure.md 中要修改的现有文件
- [ ] 记录确切路径（永远不在 aidlc-docs/ 中）
- [ ] 为单元生成创建明确步骤：
  - 项目结构设置（仅绿地项目）
  - 业务逻辑生成
  - 业务逻辑单元测试
  - 业务逻辑摘要
  - API 层生成
  - API 层单元测试
  - API 层摘要
  - 存储库层生成
  - 存储库层单元测试
  - 存储库层摘要
  - 数据库迁移脚本（如果存在数据模型）
  - 文档生成（API 文档、README 更新）
  - 部署工件生成
- [ ] 按顺序编号每个步骤
- [ ] 包含故事映射引用
- [ ] 为每个步骤添加复选框 [ ]

## 步骤 3：包含单元生成上下文
- [ ] 对于此单元，包含：
  - 此单元实现的故事
  - 对其他单元/服务的依赖关系
  - 预期接口和合约
  - 此单元拥有的数据库实体
  - 服务边界和职责

## 步骤 4：创建单元计划文档
- [ ] 将完整计划保存为 `aidlc-docs/construction/plans/{unit-name}-code-generation-plan.md`
- [ ] 包含步骤编号（步骤 1、步骤 2 等）
- [ ] 包含单元上下文和依赖关系
- [ ] 包含故事可追溯性
- [ ] 确保计划可逐步执行
- [ ] 强调此计划是代码生成的唯一真实来源

## 步骤 5：总结单元计划
- [ ] 向用户提供单元代码生成计划的摘要
- [ ] 突出单元生成方法
- [ ] 解释步骤序列和故事覆盖
- [ ] 注明总步骤数和预估范围

## 步骤 6：记录批准提示
- [ ] 在询问批准之前，在 `aidlc-docs/audit.md` 中记录带时间戳的提示
- [ ] 包含对完整单元代码生成计划的引用
- [ ] 使用 ISO 8601 时间戳格式

## 步骤 7：等待明确批准
- [ ] 在用户明确批准单元代码生成计划之前不要继续
- [ ] 批准必须涵盖整个计划和生成序列
- [ ] 如果用户请求变更，更新计划并重复批准过程

## 步骤 8：记录批准响应
- [ ] 在 `aidlc-docs/audit.md` 中记录用户的批准响应和时间戳
- [ ] 包含确切的用户响应文本
- [ ] 清楚标记批准状态

## 步骤 9：更新进度
- [ ] 在 `aidlc-state.md` 中标记代码规划完成
- [ ] 更新"当前状态"部分
- [ ] 准备过渡到代码生成

---

# 第 2 部分：生成

## 步骤 10：加载单元代码生成计划
- [ ] 从 `aidlc-docs/construction/plans/{unit-name}-code-generation-plan.md` 读取完整计划
- [ ] 识别下一个未完成的步骤（第一个 [ ] 复选框）
- [ ] 为该步骤加载上下文（单元、依赖关系、故事）

## 步骤 11：执行当前步骤
- [ ] 从计划中验证目标目录（永远不在 aidlc-docs/ 中）
- [ ] **仅棕地项目**：检查目标文件是否存在
- [ ] 准确生成当前步骤描述的内容：
  - **如果文件存在**：就地修改（永远不要创建 `ClassName_modified.java`、`ClassName_new.java` 等）
  - **如果文件不存在**：创建新文件
- [ ] 写入正确位置：
  - **应用程序代码**：按项目结构的工作区根目录
  - **文档**：`aidlc-docs/construction/{unit-name}/code/`（仅 markdown）
  - **构建/配置文件**：工作区根目录
- [ ] 遵循单元故事要求
- [ ] 尊重依赖关系和接口

## 步骤 12：更新进度
- [ ] 在单元代码生成计划中将完成的步骤标记为 [x]
- [ ] 当相关单元故事的生成完成时，将其标记为 [x]
- [ ] 更新 `aidlc-docs/aidlc-state.md` 当前状态
- [ ] **仅棕地项目**：验证未创建重复文件（例如，没有 `ClassName_modified.java` 与 `ClassName.java` 并存）
- [ ] 保存所有生成的工件

## 步骤 13：继续或完成生成
- [ ] 如果还有更多步骤，返回步骤 10
- [ ] 如果所有步骤完成，继续展示完成消息

## 步骤 14：展示完成消息
- 按此结构展示完成消息：
     1. **完成公告**（必需）：始终以此开始：

```markdown
# 💻 代码生成完成 - [unit-name]
```

     2. **AI 摘要**（可选）：提供结构化项目符号摘要
        - **棕地项目**：区分修改与创建的文件（例如，"• 修改：`src/services/user-service.ts`"，"• 创建：`src/services/auth-service.ts`"）
        - **绿地项目**：列出创建的文件及路径（例如，"• 创建：`src/services/user-service.ts`"）
        - 列出测试、文档、部署工件及路径
        - 保持事实性，无工作流指令
     3. **格式化工作流消息**（必需）：始终以此确切格式结束：

```markdown
> **📋 <u>**需要审查：**</u>**  
> 请检查生成的代码：
> - **应用程序代码**：`[actual-workspace-path]`
> - **文档**：`aidlc-docs/construction/[unit-name]/code/`



> **🚀 <u>**下一步？**</u>**
>
> **您可以：**
>
> 🔧 **请求变更** - 根据您的审查要求修改生成的代码  
> ✅ **继续下一阶段** - 批准代码生成并继续到 **[next-unit/构建和测试]**

---
```

## 步骤 15：等待明确批准
- 在用户明确批准生成的代码之前不要继续
- 批准必须清楚明确
- 如果用户请求变更，更新代码并重复批准过程

## 步骤 16：记录批准并更新进度
- 在 audit.md 中记录批准和时间戳
- 记录用户的批准响应和时间戳
- 在 aidlc-state.md 中标记此单元的代码生成阶段完成

---

## 关键规则

### 代码位置规则
- **应用程序代码**：仅工作区根目录（永远不在 aidlc-docs/ 中）
- **文档**：仅 aidlc-docs/（markdown 摘要）
- 生成代码前从 aidlc-state.md **读取工作区根目录**

**按项目类型的结构模式**：
- **棕地项目**：使用现有结构（例如，`src/main/java/`、`lib/`、`pkg/`）
- **绿地单单元**：工作区根目录中的 `src/`、`tests/`、`config/`
- **绿地多单元（微服务）**：`{unit-name}/src/`、`{unit-name}/tests/`
- **绿地多单元（单体）**：`src/{unit-name}/`、`tests/{unit-name}/`

### 棕地文件修改规则
- 生成前检查文件是否存在
- 如果存在：就地修改（永远不要创建像 `ClassName_modified.java` 这样的副本）
- 如果不存在：创建新文件
- 生成后验证无重复文件（步骤 12）

### 规划阶段规则
- 为所有生成活动创建明确的编号步骤
- 在计划中包含故事可追溯性
- 记录单元上下文和依赖关系
- 在生成前获得明确的用户批准

### 生成阶段规则
- **无硬编码逻辑**：仅执行单元计划中写的内容
- **严格遵循计划**：不要偏离步骤序列
- **更新复选框**：完成每个步骤后立即标记 [x]
- **故事可追溯性**：实现功能时标记单元故事 [x]
- **尊重依赖关系**：仅在满足单元依赖关系时实现

## 完成标准
- 创建并批准完整的单元代码生成计划
- 单元代码生成计划中的所有步骤标记为 [x]
- 根据计划实现所有单元故事
- 生成所有代码和测试（测试将在构建和测试阶段执行）
- 生成部署工件
- 完整单元已准备好进行构建和验证
