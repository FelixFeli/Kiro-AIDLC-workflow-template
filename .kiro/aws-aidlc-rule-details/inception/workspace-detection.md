# 工作区检测

**目的**：确定工作区状态并检查现有的AI-DLC项目

## 步骤1：检查现有AI-DLC项目

检查 `aidlc-docs/aidlc-state.md` 是否存在：
- **如果存在**：从上一阶段恢复（从先前阶段加载上下文）
- **如果不存在**：继续新项目评估

## 步骤2：扫描工作区中的现有代码

**确定工作区是否有现有代码：**
- 扫描工作区中的源代码文件（.java、.py、.js、.ts、.jsx、.tsx、.kt、.kts、.scala、.groovy、.go、.rs、.rb、.php、.c、.h、.cpp、.hpp、.cc、.cs、.fs等）
- 检查构建文件（pom.xml、package.json、build.gradle等）
- 寻找项目结构指标
- 识别工作区根目录（不是aidlc-docs/）

**记录发现：**
```markdown
## 工作区状态
- **现有代码**：[是/否]
- **编程语言**：[如果找到则列出]
- **构建系统**：[Maven/Gradle/npm/等，如果找到]
- **项目结构**：[单体/微服务/库/空]
- **工作区根目录**：[绝对路径]
```

## 步骤3：确定下一阶段

**如果工作区为空（无现有代码）**：
- 设置标志：`brownfield = false`
- 下一阶段：需求分析

**如果工作区有现有代码**：
- 设置标志：`brownfield = true`
- 检查 `aidlc-docs/inception/reverse-engineering/` 中现有的逆向工程工件
- **如果逆向工程工件存在**：加载它们，跳到需求分析
- **如果没有逆向工程工件**：下一阶段是逆向工程

## 步骤4：创建初始状态文件

创建 `aidlc-docs/aidlc-state.md`：

```markdown
# AI-DLC 状态跟踪

## 项目信息
- **项目类型**：[绿地/棕地]
- **开始日期**：[ISO时间戳]
- **当前阶段**：启动 - 工作区检测

## 工作区状态
- **现有代码**：[是/否]
- **需要逆向工程**：[是/否]
- **工作区根目录**：[绝对路径]

## 代码位置规则
- **应用程序代码**：工作区根目录（永远不在aidlc-docs/中）
- **文档**：仅在aidlc-docs/中
- **结构模式**：参见code-generation.md关键规则

## 阶段进度
[随着工作流进展将被填充]
```

## 步骤5：呈现完成消息

**对于棕地项目：**
```markdown
# 🔍 工作区检测完成

工作区分析发现：
• **项目类型**：棕地项目
• [AI生成的工作区发现要点摘要]
• **下一步**：进入**逆向工程**以分析现有代码库...
```

**对于绿地项目：**
```markdown
# 🔍 工作区检测完成

工作区分析发现：
• **项目类型**：绿地项目
• **下一步**：进入**需求分析**...
```

## 步骤6：自动进入

- **无需用户批准** - 这仅是信息性的
- 自动进入下一阶段：
  - **棕地**：逆向工程（如果没有现有工件）或需求分析（如果工件存在）
  - **绿地**：需求分析
